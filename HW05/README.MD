Задание
Вопросы по заданию
В этом разделе можно задать вопросы и получить ответ.
Задание по дисциплине

Дисциплина Теория и практика многопоточности

Тема ReentrantLock и Condition

Форма проверки Задание с самопроверкой

Имя преподавателя Василий Москалев

Время выполнения 3 часа

Цель задания

Научиться использовать ReentrantLock и Condition для реализации потокобезопасных классов с более точным контролем синхронизации.
Инструменты для выполнения ДЗ

IntelliJ IDEA Community / Giga IDE
Google / Яндекс документ
Правила приёма работы

Выполняйте задание по этапам.
Разместите ссылку на выполненное задание в личный кабинет
Важно: убедитесь, что доступ к документу открыт.

Критерии оценки
Задание считается выполненным, если:

прикреплена ссылка на файл с выполненным заданием;
доступ к документу открыт;
Задание не выполнено, если:

файл с заданием не прикреплён или отсутствует доступ по ссылке.
Дедлайн 30 сентября
 
 

Описание задания
Реализация потокобезопасного буфера:
Реализуйте класс BoundedBuffer, который будет представлять буфер фиксированного размера. Этот буфер должен поддерживать две основные операции:
 put(T item) — добавление элемента в буфер.
 take() — извлечение элемента из буфера.
Буфер должен быть потокобезопасным и обеспечивать корректную синхронизацию доступа с помощью ReentrantLock и Condition.
 
2. Использование ReentrantLock:

Используйте ReentrantLock для явного захвата и освобождения блокировок, что позволит вам более гибко управлять синхронизацией и предотвратить гонки данных.
Реализуйте блокировку с использованием lock() и unlock() в соответствующих местах, чтобы избежать состояния гонки при добавлении или извлечении элементов.
 
3. Использование Condition для ожидания и уведомления:

Используйте Condition для реализации механизмов ожидания и уведомления:
 await() — когда буфер пуст, потоки consumer’ов должны ожидать появления элементов.
 signal() — уведомление одного из ожидающих потоков о появлении нового элемента.
 signalAll() — уведомление всех потоков, если один или несколько элементов стали доступны для потребления.
Буфер должен поддерживать ожидания для обеих сторон: producer ожидает, если буфер полон, а consumer — если буфер пуст.
 
4. Создание producer’ов и consumer’ов:

Реализуйте несколько потоков producer’ов, которые будут добавлять элементы в буфер, и несколько потоков consumer’ов, которые будут извлекать элементы.
Каждый producer и consumer должен работать с буфером параллельно, и взаимодействие между потоками должно происходить корректно благодаря синхронизации с помощью ReentrantLock и Condition.
 
5. Тестирование и производительность:

Создайте несколько потоков producer’ов и consumer’ов для выполнения параллельных операций с буфером.
Оцените производительность системы, сравнив работу с использованием ReentrantLock с более традиционными подходами синхронизации, например, с synchronized.
 
Оформление отчёта:

Составьте отчет, в котором:

Описание каждого этапа выполнения задания.
Промежуточные результаты (например, выводы по производительности для использования ReentrantLock и других синхронизированных подходов).
Объяснение применения методов ReentrantLock и Condition для реализации потокобезопасных операций.
Примеры взаимодействия между потоками producer’ов и consumer’ов.
Итоговые выводы о преимуществах и недостатках использования ReentrantLock и Condition по сравнению с традиционными методами синхронизации.
Ссылку на отчет прикрепите в личном кабинете на платформе.

 
Чек-лист самопроверки:

Реализован потокобезопасный буфер с использованием ReentrantLock и Condition.
Использованы методы lock(), unlock(), await(), signal(), signalAll() для синхронизации работы потоков.
Реализованы несколько потоков producer’ов и consumer’ов, работающих с буфером.
Проведено тестирование на корректность работы и производительность.
Составлен отчет с описанием каждого этапа выполнения задания.
Ссылка на отчет прикреплена в личном кабинете.
