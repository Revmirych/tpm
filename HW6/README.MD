Домашнее задание (рекомендуемый дедлайн — 11 декабря)
Задание
Вопросы по заданию
В этом разделе можно задать вопросы и получить ответ.
Домашнее задание по теме 6
Дисциплина: Управление производительностью приложений.

Тема: Кэширование и оптимизация доступа к данным.

Форма проверки: задание с самопроверкой, это задание преподаватель не проверяет, но мы можем выборочно посмотреть некоторые работ на курсе.

Примерное время выполнения: 3 часа.

Цель задания:

снизить нагрузку на источник данных (БД, внешний API, файл) и ускорить ответы вашего сервиса, применив современные подходы к кэшированию.
Инструменты для выполнения задания:

Java (любая IDE, например, IntelliJ IDEA или Eclipse);
JDK 8 или выше;
Docker (для запуска Redis и второго экземпляра сервиса);
Redis (в контейнере или локально);
wrk или curl + таймер (для замеров времени ответа);
Браузер с DevTools.
Правила приёма работы:

Выполняйте задание по этапам.
Разместите ссылку на выполненное задание в личный кабинет. Убедитесь, что доступ к документу открыт.
Дедлайн: рекомендуем выполнить задание к следующему вебинару по дисциплине.

 

Описание задания:
Выберите «горячие» данные: определите, какие данные в вашем сервисе запрашиваются чаще всего и редко меняются

Реализуйте кэширование двумя способами:

Вариант A: Локальный кэш (Caffeine + Spring @Cacheable)
Настройте кэш через spring.cache.type=caffeine и аннотируйте методы сервиса @Cacheable. Укажите TTL (например, 10 минут)

Вариант B: Распределённый кэш (Redis)
Подключите Redis (через Docker), измените spring.cache.type=redis — остальной код не меняйте. Убедитесь, что кэш работает

Проведите замеры и сравните.

Используйте wrk или curl + таймер, чтобы замерить:
время первого вызова (промах в кэш)
время повторного вызова (попадание в кэш)
Запустите сервис в двух экземплярах (разные порты) и проверьте:

с Caffeine: кэш не общий (каждый инстанс делает запрос в БД)
с Redis: кэш общий (второй инстанс берёт данные из Redis)
Обеспечьте корректную инвалидацию.

Если в вашем проекте есть операции обновления (например, «обновить вакансию»), добавьте @CacheEvict, чтобы избежать отдачи устаревших данных.

 

Оформление отчёта:
Работа должна позволять оценить:

различия в поведении локального кэша (Caffeine) и распределённого кэша (Redis);
время ответа при первом обращении и повторном;
особенности работы сервиса при запуске в двух экземплярах: отсутствие общего кэша для Caffeine и наличие общего кэша для Redis;
корректность инвалидации данных после операций обновления.
В результате необходимо предоставить реализованный сценарий (конфигурации кэша и результаты замеров) и краткий аналитический вывод: как ведёт себя система при использовании разных вариантов кэширования, какие показатели были зафиксированы (время вызовов, различие между промахом и попаданием, работа двух инстансов), и есть ли предпосылки для оптимизации — например, необходимость уменьшить или увеличить TTL, изменить стратегию инвалидации или использовать распределённый кэш в многосервисной архитектуре.

Ссылку на отчёт необходимо прикрепить в личном кабинете на платформе.

 

Чек-лист самопроверки:
Определены данные, которые подходят для кэширования.
Реализован локальный кэш с использованием Caffeine.
Реализован распределённый кэш с использованием Redis.
Выполнены замеры времени первого и повторного вызова.
Сравнено время отклика при использовании Caffeine и Redis.
Сервис запущен в двух экземплярах для проверки поведения кэша.
Подтверждено, что Caffeine создаёт отдельный кэш для каждого экземпляра и Redis использует общий кэш между экземплярами.
Настроена корректная инвалидация данных через @CacheEvict.
Написан краткий отчет с описанием использованных инструментов и результатов.
Ссылка на отчет прикреплена в личном кабинете.
